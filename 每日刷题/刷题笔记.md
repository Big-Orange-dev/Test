# 刷题笔记
## 第一题
**题目介绍**

Write a function that takes in a string of one or more words, and returns the same string, but with all five or more letter words reversed (Just like the name of this Kata). Strings passed in will consist of only letters and spaces. Spaces will be included only when more than one word is present.

Examples:

spinWords( "Hey fellow warriors" ) => returns "Hey wollef sroirraw"

spinWords( "This is a test") => returns "This is a test"

spinWords( "This is another test" )=> returns "This is rehtona test"

人话讲就是 输入一句话（用英文），若句子中有单词的字母个数大于等于5，这个单词就会反转。
```python
# 我的代码
def spin_wrds(sentence):
	a = sentence.split()
	for i in range(len(a)):
		# print(len(a[i]))
		if len(a[i]) > 5:
			a[i] = list(a[i])
			a[i].reverse()
			a[i] = "".join(a[i])
			# print(a[i])
	a = " ".join(a)
	return a
```
```python
# 别人的代码,总有一些变态喜欢这样写代码，原理都差不多,但是不得不承认，真牛逼
def spin_words(sentence):
	return " ".join([x[::-1] if len(x) >= 5 else x for x in sentence.split(" ")])


# 感觉就是抄第一个的
def spin_words(sentence):
    return " ".join(word if len(word)<5 else word[::-1] for word in sentence.split())


def spin_words(sentence):
	words = [word for word in sentence.split()]
	words = [word if len(word) < 5 else word[::-1] for wors in words]
	return " ".join(words)



def spin_words(sentence):
    words = sentence.split()
    output = []
    delimiter = " "
    for word in words:
        if len(word) >= 5:
            output.append(reverse(word))
        else:
            output.append(word)
    return delimiter.join(output)
def reverse(string):
    return string[::-1]



import re
def spin_words(sentence):
    # Your code goes here
    return re.sub(r"\w{5,}", lambda w: w.group(0)[::-1], sentence)

```

## 第二题

**题目介绍**

Usually when you buy something, you're asked whether your credit card number, phone number or answer to your most secret question is still correct. However, since someone could look over your shoulder, you don't want that shown on your screen. Instead, we mask it.

Your task is to write a function `maskify`, which changes all but the last four characters into `'#'`.

```shell
# 例子：
maskify("4556364607935616") == "############5616"
maskify(     "64607935616") ==      "#######5616"
maskify(               "1") ==                "1"
maskify(                "") ==                 ""

# "What was the name of your first pet?"
maskify("Skippy")                                   == "##ippy"
maskify("Nananananananananananananananana Batman!") == "####################################man!"
```

```python
# return masked string
def maskify(cc):

    if len(cc) > 4:
        cc = list(cc)
        for i in range(len(cc) - 4):
            cc[i] = "#"
    return "".join(cc)
```

```shell
Test Results:
masking: 
  matches  
masking: 1
1  matches  1
masking: 22
22  matches  22
masking: 333
333  matches  333
masking: 4444
4444  matches  4444
masking: 3656013700
######3700  matches  ######3700
masking: 3656012840
######2840  matches  ######2840
masking: xxxx3656013004
##########3004  matches  ##########3004
masking: xxxxxx3656013136
############3136  matches  ############3136
masking: 3656013300
######3300  matches  ######3300
masking: xxxxxxxx3656013208
##############3208  matches  ##############3208
masking: xxxxxxxx3656012348
##############2348  matches  ##############2348
masking: 3656012480
######2480  matches  ######2480
masking: xxxx3656012644
##########2644  matches  ##########2644
masking: xx3656012552
########2552  matches  ########2552
masking: xxxxxx3656012716
############2716  matches  ############2716
masking: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3656011824
##################################################1824  matches  ##################################################1824
masking: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx3656011988
##############################################################################################1988  matches  ##############################################################################################1988
masking: xxxxxxxxxxxxxxxxxxxxxx3656012152
############################2152  matches  ############################2152
masking: 3656012060
######2060  matches  ######2060
```

```python
# 高人代码
# return masked string
def maskify(cc):
    return "#"*(len(cc)-4) + cc[-4:]

# return masked string
def maskify(cc):
    l = len(cc)
    if l <= 4: return cc
    return (l - 4) * '#' + cc[-4:]

# return masked string
def maskify(cc):
    return '{message:#>{fill}}'.format(message=cc[-4:], fill=len(cc))


# return masked string
def maskify(cc):
    width = len(cc)
    return cc[-4:].rjust(width, '#')
```

### 格式化类型

在占位符内，您可以添加格式化类型以格式化结果：

|      | format()                                                     |
| ---- | ------------------------------------------------------------ |
| `:<` | Left aligns the result (within the available space)                                                        左对齐结果（在可用空间内） |
| `:>` | Right aligns the result (within the available space)  右对齐结果（在可用空间内） |
| `:^` | Center aligns the result (within the available space)  居中对齐结果（在可用空间内） |
| `:=` | Places the sign to the left most position  将标志放置在最左侧 |
| `:+` | Use a plus sign to indicate if the result is positive or negative  使用加号指示结果是正数还是负数 |
| `:-` | Use a minus sign for negative values only  负号仅用于负值    |
| `: ` | Use a space to insert an extra space before positive numbers (and a minus sign befor negative numbers)  使用空格在正数之前插入一个多余的空格（在负数之前使用减号） |
| `:,` | Use a comma as a thousand separator  使用逗号作为千位分隔符  |
| `:_` | Use a underscore as a thousand separator  使用下划线作为千位分隔符 |
| `:b` | Binary format  二进制格式                                    |
| `:c` | Converts the value into the corresponding unicode character   将值转换为相应的unicode字符 |
| `:d` | Decimal format  十进制格式                                   |
| `:e` | Scientific format, with a lower case e  科学格式，小写字母e  |
| `:E` | Scientific format, with an upper case E  科学格式，带有大写字母E |
| `:f` | Fix point number format  定点编号格式                        |
| `:F` | Fix point number format, in uppercase format (show `inf` and `nan` as `INF` and `NAN`)  定点数字格式，以大写形式显示（将“ inf”和“ nan”显示为“ INF”和“ NAN”） |
| `:g` | General format  一般格式                                     |
| `:G` | General format (using a upper case E for scientific notations)  通用格式（使用大写E表示科学计数法） |
| `:o` | Octal format  八进制格式                                     |
| `:x` | Hex format, lower case  十六进制格式，小写                   |
| `:X` | Hex format, upper case  十六进制格式，大写                   |
| `:n` | Number format  数字格式                                      |
| `:%` | Percentage format  百分比格式                                |

## 第三题

**题目描述**

In this little assignment you are given a string of space separated numbers, and have to return the highest and lowest number.

**Example:**

```python
high_and_low("1 2 3 4 5")  # return "5 1"
high_and_low("1 2 -3 4 5") # return "5 -3"
high_and_low("1 9 3 4 -5") # return "9 -5"
```

```python
def high_and_low(numbers):
    # ...
    numbers = numbers.split()
    
    numbers = [ int(x) for x in numbers ]
    for i in range(len(numbers)):
        if numbers[i] < numbers[0]:
            numbers[i],numbers[0] = numbers[0],numbers[i]
        if numbers[i] > numbers[-1]:
            numbers[i],numbers[-1] = numbers[-1],numbers[i]

    numbers = " ".join([str(i) for i in numbers[-1:]+numbers[:1]])
    
    return numbers
```

```shell
Test Results:
Fixed Tests
Basic Test Cases (8 of 8 Assertions)
Completed in 0.14ms
Random tests
testing for high_and_low("1352 2400 1691 2455 1016 471 1735 225 3021 2600 710 2095 696 2114 3320 1899 334 2715 2292 1018 1655 2256")
testing for high_and_low("392 3376 406 1366 657 1667 3379 2908 1804 2509 944 1705 3378 846 1181 2926 1473 3487 896 2673 1453 1320")
testing for high_and_low("226 2761 1862 1071 1968 1921 -323 62 971 1594 1593 1885 1844 120 2147 2583 2668 37 1636 1260 -278 322")
testing for high_and_low("2591 2030 334 1039 3237 2187 3142 240 191 3043 1186 1684 3151 321 2000 903 396 1454 2145 1166 816 2372")
testing for high_and_low("2307 952 2051 2200 492 307 1558 3346 1406 1933 900 1630 2817 1920 787 371 2630 2882 1330 2205 1501 1340")
testing for high_and_low("1183 1890 3194 2557 1110 2641 1501 346 1799 479 923 2455 2706 197 1795 2068 2534 928 94 2385 1307 361")
testing for high_and_low("2120 814 1845 3306 1737 1939 2777 2396 1679 1555 910 673 273 1236 2668 535 2145 3062 2536 613 1213 2074")
testing for high_and_low("888 2808 2923 1459 2513 18 2674 2739 382 2938 1732 2572 1357 2311 3085 636 682 182 558 1370 2057 986")
testing for high_and_low("103 2678 2581 2131 402 1744 801 2255 2287 1583 1826 3102 95 869 1456 1400 746 20 80 318 876 252")
testing for high_and_low("597 1844 2013 178 2780 2730 1883 2644 1324 2043 -58 13 1951 -251 2543 -237 1295 2099 495 -176 760 2589")
Completed in 3.10ms
```

```python
# 评论区代码
def high_and_low(numbers):
    n = map(int, numbers.split(' '))
    return "{} {}".format(max(n), min(n))


def high_and_low(numbers):
  return " ".join(x(numbers.split(), key=int) for x in (max, min))
```

## 第四题

**题目描述**

A [Narcissistic Number](https://en.wikipedia.org/wiki/Narcissistic_number) is a positive number which is the sum of its own digits, each raised to the power of the number of digits in a given base. In this Kata, we will restrict ourselves to decimal (base 10).

For example, take 153 (3 digits), which is narcisstic:

```
    1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153
```

and 1652 (4 digits), which isn't:

```
    1^4 + 6^4 + 5^4 + 2^4 = 1 + 1296 + 625 + 16 = 1938
```

The Challenge:

Your code must return **true or false** depending upon whether the given number is a Narcissistic number in base 10.

Error checking for text strings or other invalid inputs is not required, only valid positive non-zero integers will be passed into the function.



```python
def narcissistic(value):
    # Code away
    num = value
    nums = []
    result = 0
    while num > 0:
        i = num % 10
        num //= 10
        nums.append(i)
        
    for i in range(len(nums)):
        result += nums[i]**len(nums) 
    
    return value==result

```

```python
# 高人代码
def narcissistic(value):
    return value == sum(int(x) ** len(str(value)) for x in str(value))


def narcissistic( value ):
    value = str(value)
    size = len(value)
    sum = 0
    for i in value:
        sum += int(i) ** size
    return sum == int(value)


def narcissistic(value):
    return bool(value==sum([int(a) ** len(str(value)) for a in str(value)]))

def narcissistic( value ):
    vstr = str(value)
    nvalue = sum(int(i)**len(vstr) for i in vstr)
    return nvalue == value

def narcissistic( value ):
    digs = map(int, str(value))
    l = len(digs)
    return value == sum(map(lambda x: x**l, digs))
```

## 第五题

**问题描述**

Jaden Smith, the son of Will Smith, is the star of films such as The Karate Kid (2010) and After Earth (2013). Jaden is also known for [some of his philosophy that he delivers via Twitter](https://twitter.com/jaden). When writing on Twitter, he is known for almost always capitalizing every word. For simplicity, you'll have to capitalize each word, check out how contractions are expected to be in the example below.

Your task is to convert strings to how they would be written by Jaden Smith. The strings are actual quotes from Jaden Smith, but they are not capitalized in the same way he originally typed them.

Example:

```
Not Jaden-Cased: "How can mirrors be real if our eyes aren't real"
Jaden-Cased:     "How Can Mirrors Be Real If Our Eyes Aren't Real"
```



```python
def to_jaden_case(string):
    # ...
    string = string.split()
    return " ".join([string[i].capitalize() for i in range(len(string))])
```





```python
# 他人代码
def toJadenCase(string):        
    return " ".join(w.capitalize() for w in string.split())

def toJadenCase(NonJadenStrings):
    return string.capwords(NonJadenStrings)


```

